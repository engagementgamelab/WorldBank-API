<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>server/public/javascript/actionheroClient.js - Engagement Lab World Bank API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Engagement Lab World Bank API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.18</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/actions.analytics.html">actions.analytics</a></li>
                                <li><a href="../classes/actions.auth.html">actions.auth</a></li>
                                <li><a href="../classes/actions.gameData.html">actions.gameData</a></li>
                                <li><a href="../classes/actions.plan.html">actions.plan</a></li>
                                <li><a href="../classes/actions.user.html">actions.user</a></li>
                                <li><a href="../classes/api.config.global.default.html">api.config.global.default</a></li>
                                <li><a href="../classes/api.config.global.production.html">api.config.global.production</a></li>
                                <li><a href="../classes/api.config.global.staging.html">api.config.global.staging</a></li>
                                <li><a href="../classes/api.config.mongo.html">api.config.mongo</a></li>
                                <li><a href="../classes/api.config.redis.html">api.config.redis</a></li>
                                <li><a href="../classes/api.config.routes.html">api.config.routes</a></li>
                                <li><a href="../classes/api.config.servers.default.html">api.config.servers.default</a></li>
                                <li><a href="../classes/api.config.servers.production.html">api.config.servers.production</a></li>
                                <li><a href="../classes/CSSPlugin.html">CSSPlugin</a></li>
                                <li><a href="../classes/initializers.auth.middleware.html">initializers.auth.middleware</a></li>
                                <li><a href="../classes/initializers.config.html">initializers.config</a></li>
                                <li><a href="../classes/initializers.mongo.html">initializers.mongo</a></li>
                                <li><a href="../classes/models.plan.html">models.plan</a></li>
                                <li><a href="../classes/models.user.html">models.user</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/api.html">api</a></li>
                                <li><a href="../modules/TweenJS.html">TweenJS</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: server/public/javascript/actionheroClient.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function UMDish(name, context, definition) {
  context[name] = definition.call(context);
  if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) {
    module.exports = context[name];
  } else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
    define(function reference() { return context[name]; });
  }
})(&quot;Primus&quot;, this, function wrapper() {
  var define, module, exports
    , Primus = (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#x27;&quot;+o+&quot;&#x27;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

/**
 * Create a function that will cleanup the instance.
 *
 * @param {Array|String} keys Properties on the instance that needs to be cleared.
 * @param {Object} options Additional configuration.
 * @returns {Function} Destroy function
 * @api public
 */
module.exports = function demolish(keys, options) {
  var split = /[, ]+/;

  options = options ||  {};
  keys = keys || [];

  if (&#x27;string&#x27; === typeof keys) keys = keys.split(split);

  /**
   * Run addition cleanup hooks.
   *
   * @param {String} key Name of the clean up hook to run.
   * @param {Mixed} selfie Reference to the instance we&#x27;re cleaning up.
   * @api private
   */
  function run(key, selfie) {
    if (!options[key]) return;
    if (&#x27;string&#x27; === typeof options[key]) options[key] = options[key].split(split);
    if (&#x27;function&#x27; === typeof options[key]) return options[key].call(selfie);

    for (var i = 0, type, what; i &lt; options[key].length; i++) {
      what = options[key][i];
      type = typeof what;

      if (&#x27;function&#x27; === type) {
        what.call(selfie);
      } else if (&#x27;string&#x27; === type &amp;&amp; &#x27;function&#x27; === typeof selfie[what]) {
        selfie[what]();
      }
    }
  }

  /**
   * Destroy the instance completely and clean up all the existing references.
   *
   * @returns {Boolean}
   * @api public
   */
  return function destroy() {
    var selfie = this
      , i = 0
      , prop;

    if (selfie[keys[0]] === null) return false;
    run(&#x27;before&#x27;, selfie);

    for (; i &lt; keys.length; i++) {
      prop = keys[i];

      if (selfie[prop]) {
        if (&#x27;function&#x27; === typeof selfie[prop].destroy) selfie[prop].destroy();
        selfie[prop] = null;
      }
    }

    if (selfie.emit) selfie.emit(&#x27;destroy&#x27;);
    run(&#x27;after&#x27;, selfie);

    return true;
  };
};

},{}],2:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

/**
 * Returns a function that when invoked executes all the listeners of the
 * given event with the given arguments.
 *
 * @returns {Function} The function that emits all the things.
 * @api public
 */
module.exports = function emits() {
  var self = this
    , parser;

  for (var i = 0, l = arguments.length, args = new Array(l); i &lt; l; i++) {
    args[i] = arguments[i];
  }

  //
  // If the last argument is a function, assume that it&#x27;s a parser.
  //
  if (&#x27;function&#x27; !== typeof args[args.length - 1]) return function emitter() {
    for (var i = 0, l = arguments.length, arg = new Array(l); i &lt; l; i++) {
      arg[i] = arguments[i];
    }

    return self.emit.apply(self, args.concat(arg));
  };

  parser = args.pop();

  /**
   * The actual function that emits the given event. It returns a boolean
   * indicating if the event was emitted.
   *
   * @returns {Boolean}
   * @api public
   */
  return function emitter() {
    for (var i = 0, l = arguments.length, arg = new Array(l + 1); i &lt; l; i++) {
      arg[i + 1] = arguments[i];
    }

    /**
     * Async completion method for the parser.
     *
     * @param {Error} err Optional error when parsing failed.
     * @param {Mixed} returned Emit instructions.
     * @api private
     */
    arg[0] = function next(err, returned) {
      if (err) return self.emit(&#x27;error&#x27;, err);

      arg = returned === undefined
        ? arg.slice(1) : returned === null
          ? [] : returned;

      self.emit.apply(self, args.concat(arg));
    };

    parser.apply(self, arg);
    return true;
  };
};

},{}],3:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

//
// We store our EE objects in a plain object whose properties are event names.
// If &#x60;Object.create(null)&#x60; is not supported we prefix the event names with a
// &#x60;~&#x60; to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that &#x60;Object.create(null)&#x60; is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== &#x27;function&#x27; ? &#x27;~&#x27; : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events &amp;&amp; this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &lt; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we&#x27;ve emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (&#x27;function&#x27; === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &lt; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &lt; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &lt; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that&#x27;s only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn&#x27;t apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
if (&#x27;undefined&#x27; !== typeof module) {
  module.exports = EventEmitter;
}

},{}],4:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var has = Object.prototype.hasOwnProperty;

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&amp;]+)=([^&amp;]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we&#x27;ve
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || &#x27;&#x27;;

  var pairs = [];

  //
  // Optionally prefix with a &#x27;?&#x27; if needed
  //
  if (&#x27;string&#x27; !== typeof prefix) prefix = &#x27;?&#x27;;

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +&#x27;=&#x27;+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join(&#x27;&amp;&#x27;) : &#x27;&#x27;;
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],5:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var EventEmitter = _dereq_(&#x27;eventemitter3&#x27;)
  , millisecond = _dereq_(&#x27;millisecond&#x27;)
  , destroy = _dereq_(&#x27;demolish&#x27;)
  , Tick = _dereq_(&#x27;tick-tock&#x27;)
  , one = _dereq_(&#x27;one-time&#x27;);

/**
 * Returns sane defaults about a given value.
 *
 * @param {String} name Name of property we want.
 * @param {Recovery} selfie Recovery instance that got created.
 * @param {Object} opts User supplied options we want to check.
 * @returns {Number} Some default value.
 * @api private
 */
function defaults(name, selfie, opts) {
  return millisecond(
    name in opts ? opts[name] : (name in selfie ? selfie[name] : Recovery[name])
  );
}

/**
 * Attempt to recover your connection with reconnection attempt.
 *
 * @constructor
 * @param {Object} options Configuration
 * @api public
 */
function Recovery(options) {
  var recovery = this;

  if (!(recovery instanceof Recovery)) return new Recovery(options);

  options = options || {};

  recovery.attempt = null;        // Stores the current reconnect attempt.
  recovery._fn = null;            // Stores the callback.

  recovery[&#x27;reconnect timeout&#x27;] = defaults(&#x27;reconnect timeout&#x27;, recovery, options);
  recovery.retries = defaults(&#x27;retries&#x27;, recovery, options);
  recovery.factor = defaults(&#x27;factor&#x27;, recovery, options);
  recovery.max = defaults(&#x27;max&#x27;, recovery, options);
  recovery.min = defaults(&#x27;min&#x27;, recovery, options);
  recovery.timers = new Tick(recovery);
}

Recovery.prototype = new EventEmitter();
Recovery.prototype.constructor = Recovery;

Recovery[&#x27;reconnect timeout&#x27;] = &#x27;30 seconds&#x27;;  // Maximum time to wait for an answer.
Recovery.max = Infinity;                       // Maximum delay.
Recovery.min = &#x27;500 ms&#x27;;                       // Minimum delay.
Recovery.retries = 10;                         // Maximum amount of retries.
Recovery.factor = 2;                           // Exponential back off factor.

/**
 * Start a new reconnect procedure.
 *
 * @returns {Recovery}
 * @api public
 */
Recovery.prototype.reconnect = function reconnect() {
  var recovery = this;

  return recovery.backoff(function backedoff(err, opts) {
    opts.duration = (+new Date()) - opts.start;

    if (err) return recovery.emit(&#x27;reconnect failed&#x27;, err, opts);

    recovery.emit(&#x27;reconnected&#x27;, opts);
  }, recovery.attempt);
};

/**
 * Exponential back off algorithm for retry operations. It uses a randomized
 * retry so we don&#x27;t DDOS our server when it goes down under pressure.
 *
 * @param {Function} fn Callback to be called after the timeout.
 * @param {Object} opts Options for configuring the timeout.
 * @returns {Recovery}
 * @api private
 */
Recovery.prototype.backoff = function backoff(fn, opts) {
  var recovery = this;

  opts = opts || recovery.attempt || {};

  //
  // Bailout when we already have a back off process running. We shouldn&#x27;t call
  // the callback then.
  //
  if (opts.backoff) return recovery;

  opts[&#x27;reconnect timeout&#x27;] = defaults(&#x27;reconnect timeout&#x27;, recovery, opts);
  opts.retries = defaults(&#x27;retries&#x27;, recovery, opts);
  opts.factor = defaults(&#x27;factor&#x27;, recovery, opts);
  opts.max = defaults(&#x27;max&#x27;, recovery, opts);
  opts.min = defaults(&#x27;min&#x27;, recovery, opts);

  opts.start = +opts.start || +new Date();
  opts.duration = +opts.duration || 0;
  opts.attempt = +opts.attempt || 0;

  //
  // Bailout if we are about to make too much attempts.
  //
  if (opts.attempt === opts.retries) {
    fn.call(recovery, new Error(&#x27;Unable to recover&#x27;), opts);
    return recovery;
  }

  //
  // Prevent duplicate back off attempts using the same options object and
  // increment our attempt as we&#x27;re about to have another go at this thing.
  //
  opts.backoff = true;
  opts.attempt++;

  recovery.attempt = opts;

  //
  // Calculate the timeout, but make it randomly so we don&#x27;t retry connections
  // at the same interval and defeat the purpose. This exponential back off is
  // based on the work of:
  //
  // http://dthain.blogspot.nl/2009/02/exponential-backoff-in-distributed.html
  //
  opts.scheduled = opts.attempt !== 1
    ? Math.min(Math.round(
        (Math.random() + 1) * opts.min * Math.pow(opts.factor, opts.attempt - 1)
      ), opts.max)
    : opts.min;

  recovery.timers.setTimeout(&#x27;reconnect&#x27;, function delay() {
    opts.duration = (+new Date()) - opts.start;
    opts.backoff = false;
    recovery.timers.clear(&#x27;reconnect, timeout&#x27;);

    //
    // Create a &#x60;one&#x60; function which can only be called once. So we can use the
    // same function for different types of invocations to create a much better
    // and usable API.
    //
    var connect = recovery._fn = one(function connect(err) {
      recovery.reset();

      if (err) return recovery.backoff(fn, opts);

      fn.call(recovery, undefined, opts);
    });

    recovery.emit(&#x27;reconnect&#x27;, opts, connect);
    recovery.timers.setTimeout(&#x27;timeout&#x27;, function timeout() {
      var err = new Error(&#x27;Failed to reconnect in a timely manner&#x27;);
      opts.duration = (+new Date()) - opts.start;

      recovery.emit(&#x27;reconnect timeout&#x27;, err, opts);
      connect(err);
    }, opts[&#x27;reconnect timeout&#x27;]);
  }, opts.scheduled);

  //
  // Emit a &#x60;reconnecting&#x60; event with current reconnect options. This allows
  // them to update the UI and provide their users with feedback.
  //
  recovery.emit(&#x27;reconnect scheduled&#x27;, opts);

  return recovery;
};

/**
 * Check if the reconnection process is currently reconnecting.
 *
 * @returns {Boolean}
 * @api public
 */
Recovery.prototype.reconnecting = function reconnecting() {
  return !!this.attempt;
};

/**
 * Tell our reconnection procedure that we&#x27;re passed.
 *
 * @param {Error} err Reconnection failed.
 * @returns {Recovery}
 * @api public
 */
Recovery.prototype.reconnected = function reconnected(err) {
  if (this._fn) this._fn(err);
  return this;
};

/**
 * Reset the reconnection attempt so it can be re-used again.
 *
 * @returns {Recovery}
 * @api public
 */
Recovery.prototype.reset = function reset() {
  this._fn = this.attempt = null;
  this.timers.clear(&#x27;reconnect, timeout&#x27;);

  return this;
};

/**
 * Clean up the instance.
 *
 * @type {Function}
 * @returns {Boolean}
 * @api public
 */
Recovery.prototype.destroy = destroy(&#x27;timers attempt _fn&#x27;);

//
// Expose the module.
//
module.exports = Recovery;

},{&quot;demolish&quot;:1,&quot;eventemitter3&quot;:3,&quot;millisecond&quot;:6,&quot;one-time&quot;:7,&quot;tick-tock&quot;:8}],6:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var regex = new RegExp(&#x27;^((?:\\d+)?\\.?\\d+) *(&#x27;+ [
  &#x27;milliseconds?&#x27;,
  &#x27;msecs?&#x27;,
  &#x27;ms&#x27;,
  &#x27;seconds?&#x27;,
  &#x27;secs?&#x27;,
  &#x27;s&#x27;,
  &#x27;minutes?&#x27;,
  &#x27;mins?&#x27;,
  &#x27;m&#x27;,
  &#x27;hours?&#x27;,
  &#x27;hrs?&#x27;,
  &#x27;h&#x27;,
  &#x27;days?&#x27;,
  &#x27;d&#x27;,
  &#x27;weeks?&#x27;,
  &#x27;wks?&#x27;,
  &#x27;w&#x27;,
  &#x27;years?&#x27;,
  &#x27;yrs?&#x27;,
  &#x27;y&#x27;
].join(&#x27;|&#x27;) +&#x27;)?$&#x27;, &#x27;i&#x27;);

var second = 1000
  , minute = second * 60
  , hour = minute * 60
  , day = hour * 24
  , week = day * 7
  , year = day * 365;

/**
 * Parse a time string and return the number value of it.
 *
 * @param {String} ms Time string.
 * @returns {Number}
 * @api private
 */
module.exports = function millisecond(ms) {
  if (&#x27;string&#x27; !== typeof ms || &#x27;0&#x27; === ms || +ms) return +ms;

  var match = regex.exec(ms)
    , amount;

  if (!match) return 0;

  amount = parseFloat(match[1]);

  switch (match[2].toLowerCase()) {
    case &#x27;years&#x27;:
    case &#x27;year&#x27;:
    case &#x27;yrs&#x27;:
    case &#x27;yr&#x27;:
    case &#x27;y&#x27;:
      return amount * year;

    case &#x27;weeks&#x27;:
    case &#x27;week&#x27;:
    case &#x27;wks&#x27;:
    case &#x27;wk&#x27;:
    case &#x27;w&#x27;:
      return amount * week;

    case &#x27;days&#x27;:
    case &#x27;day&#x27;:
    case &#x27;d&#x27;:
      return amount * day;

    case &#x27;hours&#x27;:
    case &#x27;hour&#x27;:
    case &#x27;hrs&#x27;:
    case &#x27;hr&#x27;:
    case &#x27;h&#x27;:
      return amount * hour;

    case &#x27;minutes&#x27;:
    case &#x27;minute&#x27;:
    case &#x27;mins&#x27;:
    case &#x27;min&#x27;:
    case &#x27;m&#x27;:
      return amount * minute;

    case &#x27;seconds&#x27;:
    case &#x27;second&#x27;:
    case &#x27;secs&#x27;:
    case &#x27;sec&#x27;:
    case &#x27;s&#x27;:
      return amount * second;

    default:
      return amount;
  }
};

},{}],7:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

/**
 * Wrap callbacks to prevent double execution.
 *
 * @param {Function} fn Function that should only be called once.
 * @returns {Function} A wrapped callback which prevents execution.
 * @api public
 */
module.exports = function one(fn) {
  var called = 0
    , value;

  /**
   * The function that prevents double execution.
   *
   * @api private
   */
  function onetime() {
    if (called) return value;

    called = 1;
    value = fn.apply(this, arguments);
    fn = null;

    return value;
  }

  //
  // To make debugging more easy we want to use the name of the supplied
  // function. So when you look at the functions that are assigned to event
  // listeners you don&#x27;t see a load of &#x60;onetime&#x60; functions but actually the
  // names of the functions that this module will call.
  //
  onetime.displayName = fn.displayName || fn.name || onetime.displayName || onetime.name;
  return onetime;
};

},{}],8:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var has = Object.prototype.hasOwnProperty
  , ms = _dereq_(&#x27;millisecond&#x27;);

/**
 * Timer instance.
 *
 * @constructor
 * @param {Object} timer New timer instance.
 * @param {Function} clear Clears the timer instance.
 * @param {Function} duration Duration of the timer.
 * @param {Function} fn The functions that need to be executed.
 * @api private
 */
function Timer(timer, clear, duration, fn) {
  this.start = +(new Date());
  this.duration = duration;
  this.clear = clear;
  this.timer = timer;
  this.fns = [fn];
}

/**
 * Calculate the time left for a given timer.
 *
 * @returns {Number} Time in milliseconds.
 * @api public
 */
Timer.prototype.remaining = function remaining() {
  return this.duration - this.taken();
};

/**
 * Calculate the amount of time it has taken since we&#x27;ve set the timer.
 *
 * @returns {Number}
 * @api public
 */
Timer.prototype.taken = function taken() {
  return +(new Date()) - this.start;
};

/**
 * Custom wrappers for the various of clear{whatever} functions. We cannot
 * invoke them directly as this will cause thrown errors in Google Chrome with
 * an Illegal Invocation Error
 *
 * @see #2
 * @type {Function}
 * @api private
 */
function unsetTimeout(id) { clearTimeout(id); }
function unsetInterval(id) { clearInterval(id); }
function unsetImmediate(id) { clearImmediate(id); }

/**
 * Simple timer management.
 *
 * @constructor
 * @param {Mixed} context Context of the callbacks that we execute.
 * @api public
 */
function Tick(context) {
  if (!(this instanceof Tick)) return new Tick(context);

  this.timers = {};
  this.context = context || this;
}

/**
 * Return a function which will just iterate over all assigned callbacks and
 * optionally clear the timers from memory if needed.
 *
 * @param {String} name Name of the timer we need to execute.
 * @param {Boolean} clear Also clear from memory.
 * @returns {Function}
 * @api private
 */
Tick.prototype.tock = function ticktock(name, clear) {
  var tock = this;

  return function tickedtock() {
    if (!(name in tock.timers)) return;

    var timer = tock.timers[name]
      , fns = timer.fns.slice()
      , l = fns.length
      , i = 0;

    if (clear) tock.clear(name);
    else tock.start = +new Date();

    for (; i &lt; l; i++) {
      fns[i].call(tock.context);
    }
  };
};

/**
 * Add a new timeout.
 *
 * @param {String} name Name of the timer.
 * @param {Function} fn Completion callback.
 * @param {Mixed} time Duration of the timer.
 * @returns {Tick}
 * @api public
 */
Tick.prototype.setTimeout = function timeout(name, fn, time) {
  var tick = this
    , tock;

  if (tick.timers[name]) {
    tick.timers[name].fns.push(fn);
    return tick;
  }

  tock = ms(time);
  tick.timers[name] = new Timer(
    setTimeout(tick.tock(name, true), ms(time)),
    unsetTimeout,
    tock,
    fn
  );

  return tick;
};

/**
 * Add a new interval.
 *
 * @param {String} name Name of the timer.
 * @param {Function} fn Completion callback.
 * @param {Mixed} time Interval of the timer.
 * @returns {Tick}
 * @api public
 */
Tick.prototype.setInterval = function interval(name, fn, time) {
  var tick = this
    , tock;

  if (tick.timers[name]) {
    tick.timers[name].fns.push(fn);
    return tick;
  }

  tock = ms(time);
  tick.timers[name] = new Timer(
    setInterval(tick.tock(name), ms(time)),
    unsetInterval,
    tock,
    fn
  );

  return tick;
};

/**
 * Add a new setImmediate.
 *
 * @param {String} name Name of the timer.
 * @param {Function} fn Completion callback.
 * @returns {Tick}
 * @api public
 */
Tick.prototype.setImmediate = function immediate(name, fn) {
  var tick = this;

  if (&#x27;function&#x27; !== typeof setImmediate) return tick.setTimeout(name, fn, 0);

  if (tick.timers[name]) {
    tick.timers[name].fns.push(fn);
    return tick;
  }

  tick.timers[name] = new Timer(
    setImmediate(tick.tock(name, true)),
    unsetImmediate,
    0,
    fn
  );

  return tick;
};

/**
 * Check if we have a timer set.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api public
 */
Tick.prototype.active = function active(name) {
  return name in this.timers;
};

/**
 * Properly clean up all timeout references. If no arguments are supplied we
 * will attempt to clear every single timer that is present.
 *
 * @param {Arguments} ..args.. The names of the timeouts we need to clear
 * @returns {Tick}
 * @api public
 */
Tick.prototype.clear = function clear() {
  var args = arguments.length ? arguments : []
    , tick = this
    , timer, i, l;

  if (args.length === 1 &amp;&amp; &#x27;string&#x27; === typeof args[0]) {
    args = args[0].split(/[, ]+/);
  }

  if (!args.length) {
    for (timer in tick.timers) {
      if (has.call(tick.timers, timer)) args.push(timer);
    }
  }

  for (i = 0, l = args.length; i &lt; l; i++) {
    timer = tick.timers[args[i]];

    if (!timer) continue;
    timer.clear(timer.timer);

    timer.fns = timer.timer = timer.clear = null;
    delete tick.timers[args[i]];
  }

  return tick;
};

/**
 * Adjust a timeout or interval to a new duration.
 *
 * @returns {Tick}
 * @api public
 */
Tick.prototype.adjust = function adjust(name, time) {
  var interval
    , tick = this
    , tock = ms(time)
    , timer = tick.timers[name];

  if (!timer) return tick;

  interval = timer.clear === unsetInterval;
  timer.clear(timer.timer);
  timer.start = +(new Date());
  timer.duration = tock;
  timer.timer = (interval ? setInterval : setTimeout)(tick.tock(name, !interval), tock);

  return tick;
};

/**
 * We will no longer use this module, prepare your self for global cleanups.
 *
 * @returns {Boolean}
 * @api public
 */
Tick.prototype.end = Tick.prototype.destroy = function end() {
  if (!this.context) return false;

  this.clear();
  this.context = this.timers = null;

  return true;
};

//
// Expose the timer factory.
//
Tick.Timer = Timer;
module.exports = Tick;

},{&quot;millisecond&quot;:9}],9:[function(_dereq_,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{&quot;dup&quot;:6}],10:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var required = _dereq_(&#x27;requires-port&#x27;)
  , lolcation = _dereq_(&#x27;./lolcation&#x27;)
  , qs = _dereq_(&#x27;querystringify&#x27;)
  , relativere = /^\/(?!\/)/;

/**
 * These are the parse instructions for the URL parsers, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it&#x27;s a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it&#x27;s backwards or forward parsing, when set as number it&#x27;s
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. &#x60;toLowerCase&#x60; the resulting value.
 */
var instructions = [
  [&#x27;#&#x27;, &#x27;hash&#x27;],                        // Extract from the back.
  [&#x27;?&#x27;, &#x27;query&#x27;],                       // Extract from the back.
  [&#x27;//&#x27;, &#x27;protocol&#x27;, 2, 1, 1],          // Extract from the front.
  [&#x27;/&#x27;, &#x27;pathname&#x27;],                    // Extract from the back.
  [&#x27;@&#x27;, &#x27;auth&#x27;, 1],                     // Extract from the front.
  [NaN, &#x27;host&#x27;, undefined, 1, 1],       // Set left over value.
  [/\:(\d+)$/, &#x27;port&#x27;],                 // RegExp the back.
  [NaN, &#x27;hostname&#x27;, undefined, 1, 1]    // Set left over.
];

/**
 * The actual URL instance. Instead of returning an object we&#x27;ve opted-in to
 * create an actual constructor as it&#x27;s much more memory efficient and
 * faster and it pleases my CDO.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Boolean|function} parser Parser for the query string.
 * @param {Object} location Location defaults for relative paths.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative = relativere.test(address)
    , parse, instruction, index, key
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js&#x27;s &#x60;url.parse&#x60; api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The &#x60;URL&#x60; interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if (&#x27;object&#x27; !== type &amp;&amp; &#x27;string&#x27; !== type) {
    parser = location;
    location = null;
  }

  if (parser &amp;&amp; &#x27;function&#x27; !== typeof parser) {
    parser = qs.parse;
  }

  location = lolcation(location);

  for (; i &lt; instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if (&#x27;string&#x27; === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if (&#x27;number&#x27; === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if (index = parse.exec(address)) {
      url[key] = index[1];
      address = address.slice(0, address.length - index[0].length);
    }

    url[key] = url[key] || (instruction[3] || (&#x27;port&#x27; === key &amp;&amp; relative) ? location[key] || &#x27;&#x27; : &#x27;&#x27;);

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper &#x60;origin&#x60;.
    //
    if (instruction[4]) {
      url[key] = url[key].toLowerCase();
    }
  }

  //
  // Also parse the supplied query string in to an object. If we&#x27;re supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we&#x27;re going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = &#x27;&#x27;;
  }

  //
  // Parse down the &#x60;auth&#x60; for the username and password.
  //
  url.username = url.password = &#x27;&#x27;;
  if (url.auth) {
    instruction = url.auth.split(&#x27;:&#x27;);
    url.username = instruction[0] || &#x27;&#x27;;
    url.password = instruction[1] || &#x27;&#x27;;
  }

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} prop Property we need to adjust.
 * @param {Mixed} value The newly assigned value.
 * @returns {URL}
 * @api public
 */
URL.prototype.set = function set(part, value, fn) {
  var url = this;

  if (&#x27;query&#x27; === part) {
    if (&#x27;string&#x27; === typeof value &amp;&amp; value.length) {
      value = (fn || qs.parse)(value);
    }

    url[part] = value;
  } else if (&#x27;port&#x27; === part) {
    url[part] = value;

    if (!required(value, url.protocol)) {
      url.host = url.hostname;
      url[part] = &#x27;&#x27;;
    } else if (value) {
      url.host = url.hostname +&#x27;:&#x27;+ value;
    }
  } else if (&#x27;hostname&#x27; === part) {
    url[part] = value;

    if (url.port) value += &#x27;:&#x27;+ url.port;
    url.host = value;
  } else if (&#x27;host&#x27; === part) {
    url[part] = value;

    if (/\:\d+/.test(value)) {
      value = value.split(&#x27;:&#x27;);
      url.hostname = value[0];
      url.port = value[1];
    }
  } else {
    url[part] = value;
  }

  url.href = url.toString();
  return url;
};

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
URL.prototype.toString = function toString(stringify) {
  if (!stringify || &#x27;function&#x27; !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , result = url.protocol +&#x27;//&#x27;;

  if (url.username) {
    result += url.username;
    if (url.password) result += &#x27;:&#x27;+ url.password;
    result += &#x27;@&#x27;;
  }

  result += url.hostname;
  if (url.port) result += &#x27;:&#x27;+ url.port;

  result += url.pathname;

  query = &#x27;object&#x27; === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += &#x27;?&#x27; !== query.charAt(0) ? &#x27;?&#x27;+ query : query;

  if (url.hash) result += url.hash;

  return result;
};

//
// Expose the URL parser and some additional properties that might be useful for
// others.
//
URL.qs = qs;
URL.location = lolcation;
module.exports = URL;

},{&quot;./lolcation&quot;:11,&quot;querystringify&quot;:4,&quot;requires-port&quot;:12}],11:[function(_dereq_,module,exports){
(function (global){
&#x27;use strict&#x27;;

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL&#x27;s as the a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 }
  , URL;

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the &#x60;pathname&#x60; so we can thankfully generate a good &quot;default&quot;
 * location from it so we can generate proper relative URL&#x27;s again.
 *
 * @param {Object} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
module.exports = function lolcation(loc) {
  loc = loc || global.location || {};
  URL = URL || _dereq_(&#x27;./&#x27;);

  var finaldestination = {}
    , type = typeof loc
    , key;

  if (&#x27;blob:&#x27; === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if (&#x27;string&#x27; === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if (&#x27;object&#x27; === type) for (key in loc) {
    if (key in ignore) continue;
    finaldestination[key] = loc[key];
  }

  return finaldestination;
};

}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{&quot;./&quot;:10}],12:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

/**
 * Check if we&#x27;re required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(&#x27;:&#x27;)[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case &#x27;http&#x27;:
    case &#x27;ws&#x27;:
    return port !== 80;

    case &#x27;https&#x27;:
    case &#x27;wss&#x27;:
    return port !== 443;

    case &#x27;ftp&#x27;:
    return port !== 22;

    case &#x27;gopher&#x27;:
    return port !== 70;

    case &#x27;file&#x27;:
    return false;
  }

  return port !== 0;
};

},{}],13:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var alphabet = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_&#x27;.split(&#x27;&#x27;)
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = &#x27;&#x27;;

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num &gt; 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i &lt; str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +&#x27;.&#x27;+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i &lt; length; i++) map[alphabet[i]] = i;

//
// Expose the &#x60;yeast&#x60;, &#x60;encode&#x60; and &#x60;decode&#x60; functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],14:[function(_dereq_,module,exports){
/*globals require, define */
&#x27;use strict&#x27;;

var EventEmitter = _dereq_(&#x27;eventemitter3&#x27;)
  , TickTock = _dereq_(&#x27;tick-tock&#x27;)
  , Recovery = _dereq_(&#x27;recovery&#x27;)
  , qs = _dereq_(&#x27;querystringify&#x27;)
  , destroy = _dereq_(&#x27;demolish&#x27;)
  , yeast = _dereq_(&#x27;yeast&#x27;)
  , u2028 = /\u2028/g
  , u2029 = /\u2029/g;

/**
 * Context assertion, ensure that some of our public Primus methods are called
 * with the correct context to ensure that
 *
 * @param {Primus} self The context of the function.
 * @param {String} method The method name.
 * @api private
 */
function context(self, method) {
  if (self instanceof Primus) return;

  var failure = new Error(&#x27;Primus#&#x27;+ method + &#x27;\&#x27;s context should called with a Primus instance&#x27;);

  if (&#x27;function&#x27; !== typeof self.listeners || !self.listeners(&#x27;error&#x27;).length) {
    throw failure;
  }

  self.emit(&#x27;error&#x27;, failure);
}

//
// Sets the default connection URL, it uses the default origin of the browser
// when supported but degrades for older browsers. In Node.js, we cannot guess
// where the user wants to connect to, so we just default to localhost.
//
var defaultUrl;

try {
  if (location.origin) {
    defaultUrl = location.origin;
  } else {
    defaultUrl = location.protocol +&#x27;//&#x27;+ location.hostname + (location.port ? &#x27;:&#x27;+ location.port : &#x27;&#x27;);
  }
} catch (e) {
  defaultUrl = &#x27;http://127.0.0.1&#x27;;
}

/**
 * Primus is a real-time library agnostic framework for establishing real-time
 * connections with servers.
 *
 * Options:
 * - reconnect, configuration for the reconnect process.
 * - manual, don&#x27;t automatically call &#x60;.open&#x60; to start the connection.
 * - websockets, force the use of WebSockets, even when you should avoid them.
 * - timeout, connect timeout, server didn&#x27;t respond in a timely manner.
 * - ping, The heartbeat interval for sending a ping packet to the server.
 * - pong, The heartbeat timeout for receiving a response to the ping.
 * - network, Use network events as leading method for network connection drops.
 * - strategy, Reconnection strategies.
 * - transport, Transport options.
 * - url, uri, The URL to use connect with the server.
 *
 * @constructor
 * @param {String} url The URL of your server.
 * @param {Object} options The configuration.
 * @api public
 */
function Primus(url, options) {
  if (!(this instanceof Primus)) return new Primus(url, options);
  if (&#x27;function&#x27; !== typeof this.client) {
    var message = &#x27;The client library has not been compiled correctly, &#x27; +
      &#x27;see https://github.com/primus/primus#client-library for more details&#x27;;
    return this.critical(new Error(message));
  }

  if (&#x27;object&#x27; === typeof url) {
    options = url;
    url = options.url || options.uri || defaultUrl;
  } else {
    options = options || {};
  }

  var primus = this;

  // The maximum number of messages that can be placed in queue.
  options.queueSize = &#x27;queueSize&#x27; in options ? options.queueSize : Infinity;

  // Connection timeout duration.
  options.timeout = &#x27;timeout&#x27; in options ? options.timeout : 10e3;

  // Stores the back off configuration.
  options.reconnect = &#x27;reconnect&#x27; in options ? options.reconnect : {};

  // Heartbeat ping interval.
  options.ping = &#x27;ping&#x27; in options ? options.ping : 25000;

  // Heartbeat pong response timeout.
  options.pong = &#x27;pong&#x27; in options ? options.pong : 10e3;

  // Reconnect strategies.
  options.strategy = &#x27;strategy&#x27; in options ? options.strategy : [];

  // Custom transport options.
  options.transport = &#x27;transport&#x27; in options ? options.transport : {};

  primus.buffer = [];                           // Stores premature send data.
  primus.writable = true;                       // Silly stream compatibility.
  primus.readable = true;                       // Silly stream compatibility.
  primus.url = primus.parse(url || defaultUrl); // Parse the URL to a readable format.
  primus.readyState = Primus.CLOSED;            // The readyState of the connection.
  primus.options = options;                     // Reference to the supplied options.
  primus.timers = new TickTock(this);           // Contains all our timers.
  primus.socket = null;                         // Reference to the internal connection.
  primus.latency = 0;                           // Latency between messages.
  primus.disconnect = false;                    // Did we receive a disconnect packet?
  primus.transport = options.transport;         // Transport options.
  primus.transformers = {                       // Message transformers.
    outgoing: [],
    incoming: []
  };

  //
  // Create our reconnection instance.
  //
  primus.recovery = new Recovery(options.reconnect);

  //
  // Parse the reconnection strategy. It can have the following strategies:
  //
  // - timeout: Reconnect when we have a network timeout.
  // - disconnect: Reconnect when we have an unexpected disconnect.
  // - online: Reconnect when we&#x27;re back online.
  //
  if (&#x27;string&#x27; === typeof options.strategy) {
    options.strategy = options.strategy.split(/\s?\,\s?/g);
  }

  if (false === options.strategy) {
    //
    // Strategies are disabled, but we still need an empty array to join it in
    // to nothing.
    //
    options.strategy = [];
  } else if (!options.strategy.length) {
    options.strategy.push(&#x27;disconnect&#x27;, &#x27;online&#x27;);

    //
    // Timeout based reconnection should only be enabled conditionally. When
    // authorization is enabled it could trigger.
    //
    if (!this.authorization) options.strategy.push(&#x27;timeout&#x27;);
  }

  options.strategy = options.strategy.join(&#x27;,&#x27;).toLowerCase();

  //
  // Force the use of WebSockets, even when we&#x27;ve detected some potential
  // broken WebSocket implementation.
  //
  if (&#x27;websockets&#x27; in options) {
    primus.AVOID_WEBSOCKETS = !options.websockets;
  }

  //
  // Force or disable the use of NETWORK events as leading client side
  // disconnection detection.
  //
  if (&#x27;network&#x27; in options) {
    primus.NETWORK_EVENTS = options.network;
  }

  //
  // Check if the user wants to manually initialise a connection. If they don&#x27;t,
  // we want to do it after a really small timeout so we give the users enough
  // time to listen for &#x60;error&#x60; events etc.
  //
  if (!options.manual) primus.timers.setTimeout(&#x27;open&#x27;, function open() {
    primus.timers.clear(&#x27;open&#x27;);
    primus.open();
  }, 0);

  primus.initialise(options);
}

/**
 * Simple require wrapper to make browserify, node and require.js play nice.
 *
 * @param {String} name The module to require.
 * @returns {Object|Undefined} The module that we required.
 * @api private
 */
Primus.require = function requires(name) {
  if (&#x27;function&#x27; !== typeof _dereq_) return undefined;

  return !(&#x27;function&#x27; === typeof define &amp;&amp; define.amd)
    ? _dereq_(name)
    : undefined;
};

//
// It&#x27;s possible that we&#x27;re running in Node.js or in a Node.js compatible
// environment. In this cases we inherit from the Stream base class.
//
var Stream;

try {
  Primus.Stream = Stream = Primus.require(&#x27;stream&#x27;);

  //
  // Normally inheritance is done in the same way as we do in our catch
  // statement. But due to changes to the EventEmitter interface in Node 0.10
  // this will trigger annoying memory leak warnings and other potential issues
  // outlined in the issue linked below.
  //
  // @see https://github.com/joyent/node/issues/4971
  //
  Primus.require(&#x27;util&#x27;).inherits(Primus, Stream);
} catch (e) {
  Primus.Stream = EventEmitter;
  Primus.prototype = new EventEmitter();
}

/**
 * Primus readyStates, used internally to set the correct ready state.
 *
 * @type {Number}
 * @private
 */
Primus.OPENING = 1;   // We&#x27;re opening the connection.
Primus.CLOSED  = 2;   // No active connection.
Primus.OPEN    = 3;   // The connection is open.

/**
 * Are we working with a potentially broken WebSockets implementation? This
 * boolean can be used by transformers to remove &#x60;WebSockets&#x60; from their
 * supported transports.
 *
 * @type {Boolean}
 * @private
 */
Primus.prototype.AVOID_WEBSOCKETS = false;

/**
 * Some browsers support registering emitting &#x60;online&#x60; and &#x60;offline&#x60; events when
 * the connection has been dropped on the client. We&#x27;re going to detect it in
 * a simple &#x60;try {} catch (e) {}&#x60; statement so we don&#x27;t have to do complicated
 * feature detection.
 *
 * @type {Boolean}
 * @private
 */
Primus.prototype.NETWORK_EVENTS = false;
Primus.prototype.online = true;

try {
  if (
       Primus.prototype.NETWORK_EVENTS = &#x27;onLine&#x27; in navigator
    &amp;&amp; (window.addEventListener || document.body.attachEvent)
  ) {
    if (!navigator.onLine) {
      Primus.prototype.online = false;
    }
  }
} catch (e) { }

/**
 * The Ark contains all our plugins definitions. It&#x27;s namespaced by
 * name =&gt; plugin.
 *
 * @type {Object}
 * @private
 */
Primus.prototype.ark = {};

/**
 * Simple emit wrapper that returns a function that emits an event once it&#x27;s
 * called. This makes it easier for transports to emit specific events.
 *
 * @returns {Function} A function that will emit the event when called.
 * @api public
 */
Primus.prototype.emits = _dereq_(&#x27;emits&#x27;);

/**
 * A small wrapper around &#x60;emits&#x60; to add a default parser when one is not
 * supplied. The default parser will defer the emission of the event to make
 * sure that the event is emitted at the correct time.
 *
 * @returns {Function} A function that will emit the event when called.
 * @api private
 */
Primus.prototype.trigger = function trigger() {
  for (var i = 0, l = arguments.length, args = new Array(l); i &lt; l; i++) {
    args[i] = arguments[i];
  }

  if (&#x27;function&#x27; !== typeof args[l - 1]) args.push(function defer(next) {
    setTimeout(next, 0);
  });

  return this.emits.apply(this, args);
};

/**
 * Return the given plugin.
 *
 * @param {String} name The name of the plugin.
 * @returns {Object|undefined} The plugin or undefined.
 * @api public
 */
Primus.prototype.plugin = function plugin(name) {
  context(this, &#x27;plugin&#x27;);

  if (name) return this.ark[name];

  var plugins = {};

  for (name in this.ark) {
    plugins[name] = this.ark[name];
  }

  return plugins;
};

/**
 * Checks if the given event is an emitted event by Primus.
 *
 * @param {String} evt The event name.
 * @returns {Boolean} Indication of the event is reserved for internal use.
 * @api public
 */
Primus.prototype.reserved = function reserved(evt) {
  return (/^(incoming|outgoing)::/).test(evt)
  || evt in this.reserved.events;
};

/**
 * The actual events that are used by the client.
 *
 * @type {Object}
 * @public
 */
Primus.prototype.reserved.events = {
  &#x27;reconnect scheduled&#x27;: 1,
  &#x27;reconnect timeout&#x27;: 1,
  &#x27;readyStateChange&#x27;: 1,
  &#x27;reconnect failed&#x27;: 1,
  &#x27;reconnected&#x27;: 1,
  &#x27;reconnect&#x27;: 1,
  &#x27;offline&#x27;: 1,
  &#x27;timeout&#x27;: 1,
  &#x27;online&#x27;: 1,
  &#x27;error&#x27;: 1,
  &#x27;close&#x27;: 1,
  &#x27;open&#x27;: 1,
  &#x27;data&#x27;: 1,
  &#x27;end&#x27;: 1
};

/**
 * Initialise the Primus and setup all parsers and internal listeners.
 *
 * @param {Object} options The original options object.
 * @returns {Primus}
 * @api private
 */
Primus.prototype.initialise = function initialise(options) {
  var primus = this
    , start;

  primus.recovery
  .on(&#x27;reconnected&#x27;, primus.emits(&#x27;reconnected&#x27;))
  .on(&#x27;reconnect failed&#x27;, primus.emits(&#x27;reconnect failed&#x27;, function failed(next) {
    primus.emit(&#x27;end&#x27;);
    next();
  }))
  .on(&#x27;reconnect timeout&#x27;, primus.emits(&#x27;reconnect timeout&#x27;))
  .on(&#x27;reconnect scheduled&#x27;, primus.emits(&#x27;reconnect scheduled&#x27;))
  .on(&#x27;reconnect&#x27;, primus.emits(&#x27;reconnect&#x27;, function reconnect(next) {
    primus.emit(&#x27;outgoing::reconnect&#x27;);
    next();
  }));

  primus.on(&#x27;outgoing::open&#x27;, function opening() {
    var readyState = primus.readyState;

    primus.readyState = Primus.OPENING;
    if (readyState !== primus.readyState) {
      primus.emit(&#x27;readyStateChange&#x27;, &#x27;opening&#x27;);
    }

    start = +new Date();
  });

  primus.on(&#x27;incoming::open&#x27;, function opened() {
    var readyState = primus.readyState;

    if (primus.recovery.reconnecting()) {
      primus.recovery.reconnected();
    }

    //
    // The connection has been opened so we should set our state to
    // (writ|read)able so our stream compatibility works as intended.
    //
    primus.writable = true;
    primus.readable = true;

    //
    // Make sure we are flagged as &#x60;online&#x60; as we&#x27;ve successfully opened the
    // connection.
    //
    if (!primus.online) {
      primus.online = true;
      primus.emit(&#x27;online&#x27;);
    }

    primus.readyState = Primus.OPEN;
    if (readyState !== primus.readyState) {
      primus.emit(&#x27;readyStateChange&#x27;, &#x27;open&#x27;);
    }

    primus.latency = +new Date() - start;
    primus.timers.clear(&#x27;ping&#x27;, &#x27;pong&#x27;);
    primus.heartbeat();

    if (primus.buffer.length) {
      var data = primus.buffer.slice()
        , length = data.length
        , i = 0;

      primus.buffer.length = 0;

      for (; i &lt; length; i++) {
        primus._write(data[i]);
      }
    }

    primus.emit(&#x27;open&#x27;);
  });

  primus.on(&#x27;incoming::pong&#x27;, function pong(time) {
    primus.online = true;
    primus.timers.clear(&#x27;pong&#x27;);
    primus.heartbeat();

    primus.latency = (+new Date()) - time;
  });

  primus.on(&#x27;incoming::error&#x27;, function error(e) {
    var connect = primus.timers.active(&#x27;connect&#x27;)
      , err = e;

    //
    // When the error is not an Error instance we try to normalize it.
    //
    if (&#x27;string&#x27; === typeof e) {
      err = new Error(e);
    } else if (!(e instanceof Error) &amp;&amp; &#x27;object&#x27; === typeof e) {
      //
      // BrowserChannel and SockJS returns an object which contains some
      // details of the error. In order to have a proper error we &quot;copy&quot; the
      // details in an Error instance.
      //
      err = new Error(e.message || e.reason);
      for (var key in e) {
        if (Object.prototype.hasOwnProperty.call(e, key))
          err[key] = e[key];
      }
    }
    //
    // We&#x27;re still doing a reconnect attempt, it could be that we failed to
    // connect because the server was down. Failing connect attempts should
    // always emit an &#x60;error&#x60; event instead of a &#x60;open&#x60; event.
    //
    //
    if (primus.recovery.reconnecting()) return primus.recovery.reconnected(err);
    if (primus.listeners(&#x27;error&#x27;).length) primus.emit(&#x27;error&#x27;, err);

    //
    // We received an error while connecting, this most likely the result of an
    // unauthorized access to the server.
    //
    if (connect) {
      if (~primus.options.strategy.indexOf(&#x27;timeout&#x27;)) {
        primus.recovery.reconnect();
      } else {
        primus.end();
      }
    }
  });

  primus.on(&#x27;incoming::data&#x27;, function message(raw) {
    primus.decoder(raw, function decoding(err, data) {
      //
      // Do a &quot;save&quot; emit(&#x27;error&#x27;) when we fail to parse a message. We don&#x27;t
      // want to throw here as listening to errors should be optional.
      //
      if (err) return primus.listeners(&#x27;error&#x27;).length &amp;&amp; primus.emit(&#x27;error&#x27;, err);

      //
      // Handle all &quot;primus::&quot; prefixed protocol messages.
      //
      if (primus.protocol(data)) return;
      primus.transforms(primus, primus, &#x27;incoming&#x27;, data, raw);
    });
  });

  primus.on(&#x27;incoming::end&#x27;, function end() {
    var readyState = primus.readyState;

    //
    // This &#x60;end&#x60; started with the receiving of a primus::server::close packet
    // which indicated that the user/developer on the server closed the
    // connection and it was not a result of a network disruption. So we should
    // kill the connection without doing a reconnect.
    //
    if (primus.disconnect) {
      primus.disconnect = false;

      return primus.end();
    }

    //
    // Always set the readyState to closed, and if we&#x27;re still connecting, close
    // the connection so we&#x27;re sure that everything after this if statement block
    // is only executed because our readyState is set to &#x60;open&#x60;.
    //
    primus.readyState = Primus.CLOSED;
    if (readyState !== primus.readyState) {
      primus.emit(&#x27;readyStateChange&#x27;, &#x27;end&#x27;);
    }

    if (primus.timers.active(&#x27;connect&#x27;)) primus.end();
    if (readyState !== Primus.OPEN) {
      return primus.recovery.reconnecting()
        ? primus.recovery.reconnect()
        : false;
    }

    this.writable = false;
    this.readable = false;

    //
    // Clear all timers in case we&#x27;re not going to reconnect.
    //
    this.timers.clear();

    //
    // Fire the &#x60;close&#x60; event as an indication of connection disruption.
    // This is also fired by &#x60;primus#end&#x60; so it is emitted in all cases.
    //
    primus.emit(&#x27;close&#x27;);

    //
    // The disconnect was unintentional, probably because the server has
    // shutdown, so if the reconnection is enabled start a reconnect procedure.
    //
    if (~primus.options.strategy.indexOf(&#x27;disconnect&#x27;)) {
      return primus.recovery.reconnect();
    }

    primus.emit(&#x27;outgoing::end&#x27;);
    primus.emit(&#x27;end&#x27;);
  });

  //
  // Setup the real-time client.
  //
  primus.client();

  //
  // Process the potential plugins.
  //
  for (var plugin in primus.ark) {
    primus.ark[plugin].call(primus, primus, options);
  }

  //
  // NOTE: The following code is only required if we&#x27;re supporting network
  // events as it requires access to browser globals.
  //
  if (!primus.NETWORK_EVENTS) return primus;

  /**
   * Handler for offline notifications.
   *
   * @api private
   */
  primus.offlineHandler = function offline() {
    if (!primus.online) return; // Already or still offline, bailout.

    primus.online = false;
    primus.emit(&#x27;offline&#x27;);
    primus.end();

    //
    // It is certainly possible that we&#x27;re in a reconnection loop and that the
    // user goes offline. In this case we want to kill the existing attempt so
    // when the user goes online, it will attempt to reconnect freshly again.
    //
    primus.recovery.reset();
  };

  /**
   * Handler for online notifications.
   *
   * @api private
   */
  primus.onlineHandler = function online() {
    if (primus.online) return; // Already or still online, bailout.

    primus.online = true;
    primus.emit(&#x27;online&#x27;);

    if (~primus.options.strategy.indexOf(&#x27;online&#x27;)) {
      primus.recovery.reconnect();
    }
  };

  if (window.addEventListener) {
    window.addEventListener(&#x27;offline&#x27;, primus.offlineHandler, false);
    window.addEventListener(&#x27;online&#x27;, primus.onlineHandler, false);
  } else if (document.body.attachEvent){
    document.body.attachEvent(&#x27;onoffline&#x27;, primus.offlineHandler);
    document.body.attachEvent(&#x27;ononline&#x27;, primus.onlineHandler);
  }

  return primus;
};

/**
 * Really dead simple protocol parser. We simply assume that every message that
 * is prefixed with &#x60;primus::&#x60; could be used as some sort of protocol definition
 * for Primus.
 *
 * @param {String} msg The data.
 * @returns {Boolean} Is a protocol message.
 * @api private
 */
Primus.prototype.protocol = function protocol(msg) {
  if (
       &#x27;string&#x27; !== typeof msg
    || msg.indexOf(&#x27;primus::&#x27;) !== 0
  ) return false;

  var last = msg.indexOf(&#x27;:&#x27;, 8)
    , value = msg.slice(last + 2);

  switch (msg.slice(8,  last)) {
    case &#x27;pong&#x27;:
      this.emit(&#x27;incoming::pong&#x27;, +value);
    break;

    case &#x27;server&#x27;:
      //
      // The server is closing the connection, forcefully disconnect so we don&#x27;t
      // reconnect again.
      //
      if (&#x27;close&#x27; === value) {
        this.disconnect = true;
      }
    break;

    case &#x27;id&#x27;:
      this.emit(&#x27;incoming::id&#x27;, value);
    break;

    //
    // Unknown protocol, somebody is probably sending &#x60;primus::&#x60; prefixed
    // messages.
    //
    default:
      return false;
  }

  return true;
};

/**
 * Execute the set of message transformers from Primus on the incoming or
 * outgoing message.
 * This function and it&#x27;s content should be in sync with Spark#transforms in
 * spark.js.
 *
 * @param {Primus} primus Reference to the Primus instance with message transformers.
 * @param {Spark|Primus} connection Connection that receives or sends data.
 * @param {String} type The type of message, &#x27;incoming&#x27; or &#x27;outgoing&#x27;.
 * @param {Mixed} data The data to send or that has been received.
 * @param {String} raw The raw encoded data.
 * @returns {Primus}
 * @api public
 */
Primus.prototype.transforms = function transforms(primus, connection, type, data, raw) {
  var packet = { data: data }
    , fns = primus.transformers[type];

  //
  // Iterate in series over the message transformers so we can allow optional
  // asynchronous execution of message transformers which could for example
  // retrieve additional data from the server, do extra decoding or even
  // message validation.
  //
  (function transform(index, done) {
    var transformer = fns[index++];

    if (!transformer) return done();

    if (1 === transformer.length) {
      if (false === transformer.call(connection, packet)) {
        //
        // When false is returned by an incoming transformer it means that&#x27;s
        // being handled by the transformer and we should not emit the &#x60;data&#x60;
        // event.
        //
        return;
      }

      return transform(index, done);
    }

    transformer.call(connection, packet, function finished(err, arg) {
      if (err) return connection.emit(&#x27;error&#x27;, err);
      if (false === arg) return;

      transform(index, done);
    });
  }(0, function done() {
    //
    // We always emit 2 arguments for the data event, the first argument is the
    // parsed data and the second argument is the raw string that we received.
    // This allows you, for example, to do some validation on the parsed data
    // and then save the raw string in your database without the stringify
    // overhead.
    //
    if (&#x27;incoming&#x27; === type) return connection.emit(&#x27;data&#x27;, packet.data, raw);

    connection._write(packet.data);
  }));

  return this;
};

/**
 * Retrieve the current id from the server.
 *
 * @param {Function} fn Callback function.
 * @returns {Primus}
 * @api public
 */
Primus.prototype.id = function id(fn) {
  if (this.socket &amp;&amp; this.socket.id) return fn(this.socket.id);

  this._write(&#x27;primus::id::&#x27;);
  return this.once(&#x27;incoming::id&#x27;, fn);
};

/**
 * Establish a connection with the server. When this function is called we
 * assume that we don&#x27;t have any open connections. If you do call it when you
 * have a connection open, it could cause duplicate connections.
 *
 * @returns {Primus}
 * @api public
 */
Primus.prototype.open = function open() {
  context(this, &#x27;open&#x27;);

  //
  // Only start a &#x60;connection timeout&#x60; procedure if we&#x27;re not reconnecting as
  // that shouldn&#x27;t count as an initial connection. This should be started
  // before the connection is opened to capture failing connections and kill the
  // timeout.
  //
  if (!this.recovery.reconnecting() &amp;&amp; this.options.timeout) this.timeout();

  this.emit(&#x27;outgoing::open&#x27;);
  return this;
};

/**
 * Send a new message.
 *
 * @param {Mixed} data The data that needs to be written.
 * @returns {Boolean} Always returns true as we don&#x27;t support back pressure.
 * @api public
 */
Primus.prototype.write = function write(data) {
  context(this, &#x27;write&#x27;);
  this.transforms(this, this, &#x27;outgoing&#x27;, data);

  return true;
};

/**
 * The actual message writer.
 *
 * @param {Mixed} data The message that needs to be written.
 * @returns {Boolean} Successful write to the underlaying transport.
 * @api private
 */
Primus.prototype._write = function write(data) {
  var primus = this;

  //
  // The connection is closed, normally this would already be done in the
  // &#x60;spark.write&#x60; method, but as &#x60;_write&#x60; is used internally, we should also
  // add the same check here to prevent potential crashes by writing to a dead
  // socket.
  //
  if (Primus.OPEN !== primus.readyState) {
    //
    // If the buffer is at capacity, remove the first item.
    //
    if (this.buffer.length === this.options.queueSize) {
      this.buffer.splice(0, 1);
    }

    this.buffer.push(data);
    return false;
  }

  primus.encoder(data, function encoded(err, packet) {
    //
    // Do a &quot;safe&quot; emit(&#x27;error&#x27;) when we fail to parse a message. We don&#x27;t
    // want to throw here as listening to errors should be optional.
    //
    if (err) return primus.listeners(&#x27;error&#x27;).length &amp;&amp; primus.emit(&#x27;error&#x27;, err);

    //
    // Hack 1: \u2028 and \u2029 are allowed inside a JSON string, but JavaScript
    // defines them as newline separators. Unescaped control characters are not
    // allowed inside JSON strings, so this causes an error at parse time. We
    // work around this issue by escaping these characters. This can cause
    // errors with JSONP requests or if the string is just evaluated.
    //
    if (&#x27;string&#x27; === typeof packet) {
      if (~packet.indexOf(&#x27;\u2028&#x27;)) packet = packet.replace(u2028, &#x27;\\u2028&#x27;);
      if (~packet.indexOf(&#x27;\u2029&#x27;)) packet = packet.replace(u2029, &#x27;\\u2029&#x27;);
    }

    primus.emit(&#x27;outgoing::data&#x27;, packet);
  });

  return true;
};

/**
 * Send a new heartbeat over the connection to ensure that we&#x27;re still
 * connected and our internet connection didn&#x27;t drop. We cannot use server side
 * heartbeats for this unfortunately.
 *
 * @returns {Primus}
 * @api private
 */
Primus.prototype.heartbeat = function heartbeat() {
  var primus = this;

  if (!primus.options.ping) return primus;

  /**
   * Exterminate the connection as we&#x27;ve timed out.
   *
   * @api private
   */
  function pong() {
    primus.timers.clear(&#x27;pong&#x27;);

    //
    // The network events already captured the offline event.
    //
    if (!primus.online) return;

    primus.online = false;
    primus.emit(&#x27;offline&#x27;);
    primus.emit(&#x27;incoming::end&#x27;);
  }

  /**
   * We should send a ping message to the server.
   *
   * @api private
   */
  function ping() {
    var value = +new Date();

    primus.timers.clear(&#x27;ping&#x27;);
    primus._write(&#x27;primus::ping::&#x27;+ value);
    primus.emit(&#x27;outgoing::ping&#x27;, value);
    primus.timers.setTimeout(&#x27;pong&#x27;, pong, primus.options.pong);
  }

  primus.timers.setTimeout(&#x27;ping&#x27;, ping, primus.options.ping);
  return this;
};

/**
 * Start a connection timeout.
 *
 * @returns {Primus}
 * @api private
 */
Primus.prototype.timeout = function timeout() {
  var primus = this;

  /**
   * Remove all references to the timeout listener as we&#x27;ve received an event
   * that can be used to determine state.
   *
   * @api private
   */
  function remove() {
    primus.removeListener(&#x27;error&#x27;, remove)
          .removeListener(&#x27;open&#x27;, remove)
          .removeListener(&#x27;end&#x27;, remove)
          .timers.clear(&#x27;connect&#x27;);
  }

  primus.timers.setTimeout(&#x27;connect&#x27;, function expired() {
    remove(); // Clean up old references.

    if (primus.readyState === Primus.OPEN || primus.recovery.reconnecting()) {
      return;
    }

    primus.emit(&#x27;timeout&#x27;);

    //
    // We failed to connect to the server.
    //
    if (~primus.options.strategy.indexOf(&#x27;timeout&#x27;)) {
      primus.recovery.reconnect();
    } else {
      primus.end();
    }
  }, primus.options.timeout);

  return primus.on(&#x27;error&#x27;, remove)
    .on(&#x27;open&#x27;, remove)
    .on(&#x27;end&#x27;, remove);
};

/**
 * Close the connection completely.
 *
 * @param {Mixed} data last packet of data.
 * @returns {Primus}
 * @api public
 */
Primus.prototype.end = function end(data) {
  context(this, &#x27;end&#x27;);

  if (
      this.readyState === Primus.CLOSED
    &amp;&amp; !this.timers.active(&#x27;connect&#x27;)
    &amp;&amp; !this.timers.active(&#x27;open&#x27;)
  ) {
    //
    // If we are reconnecting stop the reconnection procedure.
    //
    if (this.recovery.reconnecting()) {
      this.recovery.reset();
      this.emit(&#x27;end&#x27;);
    }

    return this;
  }

  if (data !== undefined) this.write(data);

  this.writable = false;
  this.readable = false;

  var readyState = this.readyState;
  this.readyState = Primus.CLOSED;

  if (readyState !== this.readyState) {
    this.emit(&#x27;readyStateChange&#x27;, &#x27;end&#x27;);
  }

  this.timers.clear();
  this.emit(&#x27;outgoing::end&#x27;);
  this.emit(&#x27;close&#x27;);
  this.emit(&#x27;end&#x27;);

  return this;
};

/**
 * Completely demolish the Primus instance and forcefully nuke all references.
 *
 * @returns {Boolean}
 * @api public
 */
Primus.prototype.destroy = destroy(&#x27;url timers options recovery socket transport transformers&#x27;, {
  before: &#x27;end&#x27;,
  after: [&#x27;removeAllListeners&#x27;, function detach() {
    if (!this.NETWORK_EVENTS) return;

    if (window.addEventListener) {
      window.removeEventListener(&#x27;offline&#x27;, this.offlineHandler);
      window.removeEventListener(&#x27;online&#x27;, this.onlineHandler);
    } else if (document.body.attachEvent){
      document.body.detachEvent(&#x27;onoffline&#x27;, this.offlineHandler);
      document.body.detachEvent(&#x27;ononline&#x27;, this.onlineHandler);
    }
  }]
});

/**
 * Create a shallow clone of a given object.
 *
 * @param {Object} obj The object that needs to be cloned.
 * @returns {Object} Copy.
 * @api private
 */
Primus.prototype.clone = function clone(obj) {
  return this.merge({}, obj);
};

/**
 * Merge different objects in to one target object.
 *
 * @param {Object} target The object where everything should be merged in.
 * @returns {Object} Original target with all merged objects.
 * @api private
 */
Primus.prototype.merge = function merge(target) {
  var args = Array.prototype.slice.call(arguments, 1);

  for (var i = 0, l = args.length, key, obj; i &lt; l; i++) {
    obj = args[i];

    for (key in obj) {
      if (obj.hasOwnProperty(key)) target[key] = obj[key];
    }
  }

  return target;
};

/**
 * Parse the connection string.
 *
 * @type {Function}
 * @param {String} url Connection URL.
 * @returns {Object} Parsed connection.
 * @api private
 */
Primus.prototype.parse = _dereq_(&#x27;url-parse&#x27;);

/**
 * Parse a query string.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object} Parsed query string.
 * @api private
 */
Primus.prototype.querystring = qs.parse;
/**
 * Transform a query string object back into string equiv.
 *
 * @param {Object} obj The query string object.
 * @returns {String}
 * @api private
 */
Primus.prototype.querystringify = qs.stringify;

/**
 * Generates a connection URI.
 *
 * @param {String} protocol The protocol that should used to crate the URI.
 * @returns {String|options} The URL.
 * @api private
 */
Primus.prototype.uri = function uri(options) {
  var url = this.url
    , server = []
    , qsa = false;

  //
  // Query strings are only allowed when we&#x27;ve received clearance for it.
  //
  if (options.query) qsa = true;

  options = options || {};
  options.protocol = &#x27;protocol&#x27; in options
    ? options.protocol
    : &#x27;http:&#x27;;
  options.query = url.query &amp;&amp; qsa
    ? url.query.slice(1)
    : false;
  options.secure = &#x27;secure&#x27; in options
    ? options.secure
    : url.protocol === &#x27;https:&#x27; || url.protocol === &#x27;wss:&#x27;;
  options.auth = &#x27;auth&#x27; in options
    ? options.auth
    : url.auth;
  options.pathname = &#x27;pathname&#x27; in options
    ? options.pathname
    : this.pathname;
  options.port = &#x27;port&#x27; in options
    ? +options.port
    : +url.port || (options.secure ? 443 : 80);

  //
  // Allow transformation of the options before we construct a full URL from it.
  //
  this.emit(&#x27;outgoing::url&#x27;, options);

  //
  // We need to make sure that we create a unique connection URL every time to
  // prevent back forward cache from becoming an issue. We&#x27;re doing this by
  // forcing an cache busting query string in to the URL.
  //
  var querystring = this.querystring(options.query || &#x27;&#x27;);
  querystring._primuscb = yeast();
  options.query = this.querystringify(querystring);

  //
  // Automatically suffix the protocol so we can supply &#x60;ws:&#x60; and &#x60;http:&#x60; and
  // it gets transformed correctly.
  //
  server.push(options.secure ? options.protocol.replace(&#x27;:&#x27;, &#x27;s:&#x27;) : options.protocol, &#x27;&#x27;);

  server.push(options.auth ? options.auth +&#x27;@&#x27;+ url.host : url.host);

  //
  // Pathnames are optional as some Transformers would just use the pathname
  // directly.
  //
  if (options.pathname) server.push(options.pathname.slice(1));

  //
  // Optionally add a search query.
  //
  if (qsa) server.push(&#x27;?&#x27;+ options.query);
  else delete options.query;

  if (options.object) return options;
  return server.join(&#x27;/&#x27;);
};

/**
 * Register a new message transformer. This allows you to easily manipulate incoming
 * and outgoing data which is particularity handy for plugins that want to send
 * meta data together with the messages.
 *
 * @param {String} type Incoming or outgoing
 * @param {Function} fn A new message transformer.
 * @returns {Primus}
 * @api public
 */
Primus.prototype.transform = function transform(type, fn) {
  context(this, &#x27;transform&#x27;);

  if (!(type in this.transformers)) {
    return this.critical(new Error(&#x27;Invalid transformer type&#x27;));
  }

  this.transformers[type].push(fn);
  return this;
};

/**
 * A critical error has occurred, if we have an &#x60;error&#x60; listener, emit it there.
 * If not, throw it, so we get a stack trace + proper error message.
 *
 * @param {Error} err The critical error.
 * @returns {Primus}
 * @api private
 */
Primus.prototype.critical = function critical(err) {
  if (this.listeners(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
    return this;
  }

  throw err;
};

/**
 * Syntax sugar, adopt a Socket.IO like API.
 *
 * @param {String} url The URL we want to connect to.
 * @param {Object} options Connection options.
 * @returns {Primus}
 * @api public
 */
Primus.connect = function connect(url, options) {
  return new Primus(url, options);
};

//
// Expose the EventEmitter so it can be re-used by wrapping libraries we&#x27;re also
// exposing the Stream interface.
//
Primus.EventEmitter = EventEmitter;

//
// These libraries are automatically are automatically inserted at the
// server-side using the Primus#library method.
//
Primus.prototype.client = function client() {
  var primus = this
    , socket;

  //
  // Select an available WebSocket factory.
  //
  var Factory = (function factory() {
    if (&#x27;undefined&#x27; !== typeof WebSocket) return WebSocket;
    if (&#x27;undefined&#x27; !== typeof MozWebSocket) return MozWebSocket;

    try { return Primus.require(&#x27;ws&#x27;); }
    catch (e) {}

    return undefined;
  })();

  if (!Factory) return primus.critical(new Error(
    &#x27;Missing required &#x60;ws&#x60; module. Please run &#x60;npm install --save ws&#x60;&#x27;
  ));


  //
  // Connect to the given URL.
  //
  primus.on(&#x27;outgoing::open&#x27;, function opening() {
    primus.emit(&#x27;outgoing::end&#x27;);

    //
    // FireFox will throw an error when we try to establish a connection from
    // a secure page to an unsecured WebSocket connection. This is inconsistent
    // behaviour between different browsers. This should ideally be solved in
    // Primus when we connect.
    //
    try {
      var prot = primus.url.protocol === &#x27;ws+unix:&#x27; ? &#x27;ws+unix:&#x27; : &#x27;ws:&#x27;
        , qsa = prot === &#x27;ws:&#x27;;

      //
      // Only allow primus.transport object in Node.js, it will throw in
      // browsers with a TypeError if we supply to much arguments.
      //
      if (Factory.length === 3) {
        primus.socket = socket = new Factory(
          primus.uri({ protocol: prot, query: qsa }),   // URL
          [],                                           // Sub protocols
          primus.transport                              // options.
        );
      } else {
        primus.socket = socket = new Factory(primus.uri({
          protocol: prot,
          query: qsa
        }));
      }
    } catch (e) { return primus.emit(&#x27;error&#x27;, e); }

    //
    // Setup the Event handlers.
    //
    socket.binaryType = &#x27;arraybuffer&#x27;;
    socket.onopen = primus.trigger(&#x27;incoming::open&#x27;);
    socket.onerror = primus.trigger(&#x27;incoming::error&#x27;);
    socket.onclose = primus.trigger(&#x27;incoming::end&#x27;);
    socket.onmessage = primus.trigger(&#x27;incoming::data&#x27;, function parse(next, evt) {
      setTimeout(function defer() {
        next(undefined, evt.data);
      }, 0);
    });
  });

  //
  // We need to write a new message to the socket.
  //
  primus.on(&#x27;outgoing::data&#x27;, function write(message) {
    if (!socket || socket.readyState !== Factory.OPEN) return;

    try { socket.send(message); }
    catch (e) { primus.emit(&#x27;incoming::error&#x27;, e); }
  });

  //
  // Attempt to reconnect the socket.
  //
  primus.on(&#x27;outgoing::reconnect&#x27;, function reconnect() {
    primus.emit(&#x27;outgoing::open&#x27;);
  });

  //
  // We need to close the socket.
  //
  primus.on(&#x27;outgoing::end&#x27;, function close() {
    if (!socket) return;

    socket.onerror = socket.onopen = socket.onclose = socket.onmessage = function () {};
    socket.close();
    socket = null;
  });
};
Primus.prototype.authorization = false;
Primus.prototype.pathname = &quot;/primus&quot;;
Primus.prototype.encoder = function encoder(data, fn) {
  var err;

  try { data = JSON.stringify(data); }
  catch (e) { err = e; }

  fn(err, data);
};
Primus.prototype.decoder = function decoder(data, fn) {
  var err;

  if (&#x27;string&#x27; !== typeof data) return fn(err, data);

  try { data = JSON.parse(data); }
  catch (e) { err = e; }

  fn(err, data);
};
Primus.prototype.version = &quot;4.0.1&quot;;

if (
     &#x27;undefined&#x27; !== typeof document
  &amp;&amp; &#x27;undefined&#x27; !== typeof navigator
) {
  //
  // Hack 2: If you press ESC in FireFox it will close all active connections.
  // Normally this makes sense, when your page is still loading. But versions
  // before FireFox 22 will close all connections including WebSocket connections
  // after page load. One way to prevent this is to do a &#x60;preventDefault()&#x60; and
  // cancel the operation before it bubbles up to the browsers default handler.
  // It needs to be added as &#x60;keydown&#x60; event, if it&#x27;s added keyup it will not be
  // able to prevent the connection from being closed.
  //
  if (document.addEventListener) {
    document.addEventListener(&#x27;keydown&#x27;, function keydown(e) {
      if (e.keyCode !== 27 || !e.preventDefault) return;

      e.preventDefault();
    }, false);
  }

  //
  // Hack 3: This is a Mac/Apple bug only, when you&#x27;re behind a reverse proxy or
  // have you network settings set to &#x60;automatic proxy discovery&#x60; the safari
  // browser will crash when the WebSocket constructor is initialised. There is
  // no way to detect the usage of these proxies available in JavaScript so we
  // need to do some nasty browser sniffing. This only affects Safari versions
  // lower then 5.1.4
  //
  var ua = (navigator.userAgent || &#x27;&#x27;).toLowerCase()
    , parsed = ua.match(/.+(?:rv|it|ra|ie)[\/: ](\d+)\.(\d+)(?:\.(\d+))?/) || []
    , version = +[parsed[1], parsed[2]].join(&#x27;.&#x27;);

  if (
       !~ua.indexOf(&#x27;chrome&#x27;)
    &amp;&amp; ~ua.indexOf(&#x27;safari&#x27;)
    &amp;&amp; version &lt; 534.54
  ) {
    Primus.prototype.AVOID_WEBSOCKETS = true;
  }
}

//
// Expose the library.
//
module.exports = Primus;

},{&quot;demolish&quot;:1,&quot;emits&quot;:2,&quot;eventemitter3&quot;:3,&quot;querystringify&quot;:4,&quot;recovery&quot;:5,&quot;tick-tock&quot;:8,&quot;url-parse&quot;:10,&quot;yeast&quot;:13}]},{},[14])(14);
  return Primus;
});



;;;
(function(exports){ 
var ActionheroClient = function(options, client){

  var self = this;

  self.callbacks = {};
  self.id = null;
  self.events = {};
  self.rooms = [];
  self.state = &#x27;disconnected&#x27;;

  self.options = self.defaults();
  for(var i in options){
    self.options[i] = options[i];
  }

  if(client){
    self.externalClient = true;
    self.client = client;
  }
}

if(typeof Primus === &#x27;undefined&#x27;){
  var util = require(&#x27;util&#x27;);
  var EventEmitter = require(&#x27;events&#x27;).EventEmitter;
  util.inherits(ActionheroClient, EventEmitter);
}else{
  ActionheroClient.prototype = new Primus.EventEmitter();
}

ActionheroClient.prototype.defaults = function(){
  return { apiPath: &#x27;/api&#x27;, url: window.location.origin }
}

////////////////
// CONNECTION //
////////////////

ActionheroClient.prototype.connect = function(callback){
  var self = this;
  self.messageCount = 0;


  if(self.client &amp;&amp; self.externalClient !== true){
    self.client.end();
    self.client.removeAllListeners();
    delete self.client;
    self.client = Primus.connect(self.options.url, self.options);
  }
  if(self.client &amp;&amp; self.externalClient === true){
    self.client.end();
    self.client.open();
  }else{
    self.client = Primus.connect(self.options.url, self.options);
  }

  self.client.on(&#x27;open&#x27;, function(){
    self.configure(function(details){
      self.emit(&#x27;connected&#x27;);
      if(self.state === &#x27;connected&#x27;){
        //
      }else{
        self.state = &#x27;connected&#x27;;
        if(typeof callback === &#x27;function&#x27;){ callback(null, details); }
      }
    });
  })

  self.client.on(&#x27;error&#x27;, function(err){
    self.emit(&#x27;error&#x27;, err);
  });

  self.client.on(&#x27;reconnect&#x27;, function(){
    self.messageCount = 0;
    self.emit(&#x27;reconnect&#x27;);
  });

  self.client.on(&#x27;reconnecting&#x27;, function(){
    self.emit(&#x27;reconnecting&#x27;);
    self.state = &#x27;reconnecting&#x27;;
    self.emit(&#x27;disconnected&#x27;);
  });

  self.client.on(&#x27;timeout&#x27;, function(){
    self.state = &#x27;timeout&#x27;;
    self.emit(&#x27;timeout&#x27;);
  });

  self.client.on(&#x27;close&#x27;, function(){
    self.messageCount = 0;
    if(self.state !== &#x27;disconnected&#x27;){
      self.state = &#x27;disconnected&#x27;;
      self.emit(&#x27;disconnected&#x27;);
    }
  });

  self.client.on(&#x27;end&#x27;, function(){
    self.messageCount = 0;
    if(self.state !== &#x27;disconnected&#x27;){
      self.state = &#x27;disconnected&#x27;;
      self.emit(&#x27;disconnected&#x27;);
    }
  });

  self.client.on(&#x27;data&#x27;, function(data){
    self.handleMessage(data);
  });
}

ActionheroClient.prototype.configure = function(callback){
  var self = this;

  self.rooms.forEach(function(room){
    self.send({event: &#x27;roomAdd&#x27;, room: room});
  });

  self.detailsView(function(details){
    self.id          = details.data.id;
    self.fingerprint = details.data.fingerprint;
    self.rooms       = details.data.rooms;
    callback(details);
  }); 
}

///////////////
// MESSAGING //
///////////////

ActionheroClient.prototype.send = function(args, callback){
  // primus will buffer messages when not connected
  var self = this;
  self.messageCount++;
  if(typeof callback === &#x27;function&#x27;){
    self.callbacks[self.messageCount] = callback;
  }
  self.client.write(args);
}

ActionheroClient.prototype.handleMessage = function(message){
  var self = this;
  self.emit(&#x27;message&#x27;, message);
  if(message.context === &#x27;response&#x27;){
    if(typeof self.callbacks[message.messageCount] === &#x27;function&#x27;){
      self.callbacks[message.messageCount](message);
    }
    delete self.callbacks[message.messageCount];
  } else if(message.context === &#x27;user&#x27;){
    self.emit(&#x27;say&#x27;, message);
  } else if(message.context === &#x27;alert&#x27;){
    self.emit(&#x27;alert&#x27;, message);
  } else if(message.welcome &amp;&amp; message.context === &#x27;api&#x27;){
    self.welcomeMessage = message.welcome;
    self.emit(&#x27;welcome&#x27;, message);
  } else if(message.context === &#x27;api&#x27;){
    self.emit(&#x27;api&#x27;, message);
  }
}

/////////////
// ACTIONS //
/////////////

ActionheroClient.prototype.action = function(action, params, callback){
  if(!callback &amp;&amp; typeof params === &#x27;function&#x27;){
    callback = params;
    params = null;
  }
  if(!params){ params = {}; }
  params.action = action;
  
  if(this.state !== &#x27;connected&#x27;){
    this.actionWeb(params, callback);
  }else{
    this.actionWebSocket(params, callback);
  }
}

ActionheroClient.prototype.actionWeb = function(params, callback) {
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.onreadystatechange = function () {
    var response;
    if(xmlhttp.readyState === 4) {
      if(xmlhttp.status === 200) {
        response = JSON.parse(xmlhttp.responseText);
      }else{
        try{
          response = JSON.parse(xmlhttp.responseText);
        }catch(e){
          response = { error: {statusText: xmlhttp.statusText, responseText: xmlhttp.responseText} };
        }
      }
      callback(response);
    }
  };
  
  var method = params.httpMethod || &#x27;POST&#x27;;
  var url = this.options.url + this.options.apiPath + &#x27;?action=&#x27; + params.action;
  xmlhttp.open(method, url, true);
  xmlhttp.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
  xmlhttp.send(JSON.stringify(params)); 
}


ActionheroClient.prototype.actionWebSocket = function(params, callback){
  this.send({event: &#x27;action&#x27;,params: params}, callback);
}

//////////////
// COMMANDS //
//////////////

ActionheroClient.prototype.say = function(room, message, callback){
  this.send({event: &#x27;say&#x27;, room: room, message: message}, callback);
}

ActionheroClient.prototype.file = function(file, callback){
  this.send({event: &#x27;file&#x27;, file: file}, callback);
}

ActionheroClient.prototype.detailsView = function(callback){
  this.send({event: &#x27;detailsView&#x27;}, callback);
}

ActionheroClient.prototype.roomView = function(room, callback){
  this.send({event: &#x27;roomView&#x27;, room: room}, callback);
}

ActionheroClient.prototype.roomAdd = function(room, callback){
  var self = this;
  self.send({event: &#x27;roomAdd&#x27;, room: room}, function(data){
    self.configure(function(){
      if(typeof callback === &#x27;function&#x27;){ callback(data); }
    });
  });
}

ActionheroClient.prototype.roomLeave = function(room, callback){
  var self = this;
  var index = self.rooms.indexOf(room);
  if(index &gt; -1){ self.rooms.splice(index, 1); }
  this.send({event: &#x27;roomLeave&#x27;, room: room}, function(data){
    self.configure(function(){
      if(typeof callback === &#x27;function&#x27;){ callback(data); }
    });
  });
}

ActionheroClient.prototype.documentation = function(callback){
  this.send({event: &#x27;documentation&#x27;}, callback);
}

ActionheroClient.prototype.disconnect = function(){
  this.state = &#x27;disconnected&#x27;;
  this.client.end();
  this.emit(&#x27;disconnected&#x27;);
}

// depricated lowercase name
var actionheroClient = ActionheroClient;

exports.ActionheroClient = ActionheroClient; 
exports.actionheroClient = actionheroClient; 
})(typeof exports === &#x27;undefined&#x27; ? window : exports);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
